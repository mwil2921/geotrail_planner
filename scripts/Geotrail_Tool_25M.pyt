# -*- coding: utf-8 -*-"""Created on Tue June 19 2024@author: Mark WilliamsUniversity of Tasmaniamark.williams@utas.edu.auGeotrail Least Cost Path ToolPython toolbox created using ArcGIS Pro 3.2.2Supplementary code associated with publicationWilliams, M.A., Rolls, S., McHenry, M.T.(2024).Optimising Geotrail Planning by Leveraging Least-Cost Path for Sustainable Geotourism Development: A Case Study on a Tasmanian West Coast Post-Mining Landscape."""########################Import python site packages############################import arcpy  # Import the arcpy objectimport os.path  # Used for filename handlingfrom arcpy.sa import * # Import Spatial Analyst tools############################Setup Variables#####################################Setup filename variables for inputs and outputs#the INPATH should be the full path where the geodatabase is storedINPATH = "C:\\Geotrail_Tool\\Geotrail_Tool.gdb"OUTPATH = INPATHclass Toolbox:    def __init__(self):        """Define the toolbox (the name of the toolbox is the name of the        .pyt file)."""        self.label = "Toolbox"        self.alias = "toolbox"        # List of tool classes associated with this toolbox        self.tools = [CreateGeotrail]def create_parameter(display_name, name, datatype, default_value, parameter_type="Required", direction="Input"):    """Helper function to create parameters for the tool."""    param = arcpy.Parameter(        displayName=display_name,        name=name,        datatype=datatype,        parameterType=parameter_type,        direction=direction    )    param.value = default_value    return paramclass CreateGeotrail:    def __init__(self):        """Define the tool (tool name is the name of the class)."""        self.label = "Create Geotrail"        self.description = "Creates new geotrails using path distance algorithms"    def getParameterInfo(self):        """Define the tool parameters."""        # Default parameters are given but can be changes used tool interface. This prototype uses a 25M although it is recommended to use the finest detailed data available.        # The above mentioned study used 2M resolution datasets        # Weights can be determined using a qualitative judgement or using AHP method. A separate python script AHP_criteria_weights.py can be used to calculate weights.        params = []        #Example below contains weights for Miners Legacy Track after geotrail path has been field validated        #Criterion 1 (Slope) - Use slopes up to 20% and avoid those over 45 degrees for accessibility and lower maintenance costs.        params.append(create_parameter("Slope Weight", "slope_weight", "GPDouble", 0.348322))        params.append(create_parameter("Slope Criteria", "slope_raster", "DERasterDataset", os.path.join(INPATH, "crit1_slope_25M")))        #Criterion 2 (Landforms) - Favour ridgelines for lower costs and better views, avoiding valleys and pits due to higher costs and less scenic views.        params.append(create_parameter("Landforms Weight", "land_weight", "GPDouble", 0.186116))        params.append(create_parameter("Landforms Criteria", "land_raster", "DERasterDataset", os.path.join(INPATH, "crit2_landforms_25M")))        #Criterion 3 (Roads) - Increased distance from roads enhances safety and walking experience, though it reduces emergency access.        params.append(create_parameter("Roads Weight", "roads_weight", "GPDouble", 0.024306))        params.append(create_parameter("Roads Criteria", "roads_raster", "DERasterDataset", os.path.join(INPATH, "crit3_roads_25M")))        #Criterion 4 (Soil) - Preference well-drained soils to mitigate erosion risks and reduce maintenance costs.        params.append(create_parameter("Soil Weight", "soil_weight", "GPDouble", 0.234422))        params.append(create_parameter("Soil Criteria", "soil_raster", "DERasterDataset", os.path.join(INPATH, "crit4_soil_25M")))        #Criterion 5 (Geosites) - Proximity to geosites enhances geotrail value, with short side tracks recommended to access sites and viewpoints without causing degradation.        params.append(create_parameter("Geosites Weight", "geosites_weight", "GPDouble", 0.087072))        params.append(create_parameter("Geosites Criteria", "geosites_raster", "DERasterDataset", os.path.join(INPATH, "crit5_geosites_miners_legacy_25M")))        #Criterion 6 (Utilities) - Distance from powerlines enhances visitor experience and reduces hazards.        params.append(create_parameter("Utilities Weight", "utilities_weight", "GPDouble", 0.036632))        params.append(create_parameter("Utilities Criteria", "utilities_raster", "DERasterDataset", os.path.join(INPATH, "crit6_utilities_25M")))        #Criterion 7 (Vegetation) - Prefer aesthetically pleasing, ecologically valuable vegetation, avoiding threatened types and minimizing construction damage.        params.append(create_parameter("Vegetation Weight", "veg_weight", "GPDouble", 0.035536))        params.append(create_parameter("Vegetation Criteria", "veg_raster", "DERasterDataset", os.path.join(INPATH, "crit7_veg_25M")))        #Criterion 8 (Rivers) - Distance from streams reduces crossings, improves safety, and lowers costs, but remote walkers need water access; exclude lakes, dams, and wetlands.        params.append(create_parameter("Rivers Weight", "rivers_weight", "GPDouble", 0.047593))        params.append(create_parameter("Rivers Criteria", "rivers_raster", "DERasterDataset", os.path.join(INPATH, "crit8_rivers_25M")))        #Trail heads (start and end points) - these are used for the origin and destination in the least cost path analysis        params.append(create_parameter("Trail Start Point", "trail_start", "GPFeatureRecordSetLayer", None))        params.append(create_parameter("Trail End Point", "trail_end", "GPFeatureRecordSetLayer", None))        #Output Geotrail - The output line feature class for the resultant geotrail        params.append(create_parameter("Geotrail", "geotrail", "DEFeatureClass", os.path.join(INPATH, "Geotrail"), "Required", "Output"))        return params    def isLicensed(self):        """Set whether the tool is licensed to execute."""        return True    def updateParameters(self, parameters):        """Modify the values and properties of parameters before internal        validation is performed.  This method is called whenever a parameter        has been changed."""        #check that weights are not more than 100%        return    def updateMessages(self, parameters):        """Modify the messages created by internal validation for each tool        parameter. This method is called after internal validation."""        return    def execute(self, parameters, messages):        #Retrieve user criteria parameters        crit1_weight = float(parameters[0].valueAsText)        crit1 = Raster(parameters[1].valueAsText)        crit2_weight = float(parameters[2].valueAsText)        crit2 = Raster(parameters[3].valueAsText)        crit3_weight = float(parameters[4].valueAsText)        crit3 = Raster(parameters[5].valueAsText)        crit4_weight = float(parameters[6].valueAsText)        crit4 = Raster(parameters[7].valueAsText)        crit5_weight = float(parameters[8].valueAsText)        crit5 = Raster(parameters[9].valueAsText)        crit6_weight = float(parameters[10].valueAsText)        crit6 = Raster(parameters[11].valueAsText)        crit7_weight = float(parameters[12].valueAsText)        crit7 = Raster(parameters[13].valueAsText)        crit8_weight = float(parameters[14].valueAsText)        crit8 = Raster(parameters[15].valueAsText)        #Produce cost surface using the Weighted Linear Combination algorithm        Geotrail_Cost_Surface = (                (crit1 * crit1_weight) +                (crit2 * crit2_weight) +                (crit3 * crit3_weight) +                (crit4 * crit4_weight) +                (crit5 * crit5_weight) +                (crit6 * crit6_weight) +                (crit7 * crit7_weight) +                (crit8 * crit8_weight)        )        ##Distance Accumulation Parameters##        trail_start = parameters[16].valueAsText #origin trailhead        trail_end = parameters[17].valueAsText #destination trailhead        #Follow contours to ensure smooth geotrail flow, easy walking, and proper water drainage.        #The contours raster is an aspect raster rotated 90 degrees        contours = os.path.join(INPATH, "Horizontal_factors_contours_25M")        #Barries avoid private land, special conservation areas, and waterbodies such as lakes and dams        barriers = os.path.join(INPATH, "barriers_miners_legacy_25M")        # Define the horizontal factor (HfLinear) - this represents a linear function to apply an additional cost factor        #HfLinear(Zero Factor, Cut Angle, Slope)        # Zero Factor = 1 - no additional cost if follow the contours        # Cut Angle - 181 - this means all directions of travel are allowed although contours are favoured        # Slope - 1/180 - a very shallow slope meaning the moving away from contours only gradually increases cost applied        horizontal_factor = HfLinear(1, 181, 0.00555555555)        #A backlink raster is a grid that shows the direction to move from each cell to reach the source along the least-cost path.        Backlink = r"memory\backlink"        #Distance accumulation algorithm includes trailhead (origin), the cost surface, horizontal factor (contours), horizontal factor parameters and backlink        outDistAcc = DistanceAccumulation(trail_start, barriers, "", Geotrail_Cost_Surface, "", "", contours, horizontal_factor, Backlink)        #Create Geotrail Line Feature        Geotrail = parameters[18].valueAsText        OptimalPathAsLine(trail_end, outDistAcc, Backlink, Geotrail, "OBJECTID")        return    def postExecute(self, parameters):        """This method takes place after outputs are processed and        added to the display."""        return